# 41141128

作業一

## 解題說明
說明 Ackermann 函數的邏輯與性質

### 解題策略
1.遞迴思維建立
遇到 m=0 就回傳 n+1，是最底層，遇到 n=0，則往左邊減一層 m，從 n=1 重啟，其他情況會展開成「雙層遞迴」，這是最困難處。

2,遞迴實作策略
根據題目的公式，用 if-else 條件寫出 base case 與 recursive case，要注意的是語法會需要「先算裡面的再算外面的」，Python 的 call stack 可以自然處理這樣的流程。

3：非遞迴策略
用 stack（堆疊）模擬系統 call stack，每次記錄 (m, n) 當前狀態，根據條件把下一步推入 stack，特別是 A(m-1, A(m, n-1))，需要等到內部 A(m, n-1) 得出值後，才能處理外層 A(m-1, x)。



## 程式實作

以下為主要程式碼：

```cpp
def ackermann(m, n):
    if m == 0:
        return n + 1
    elif n == 0:
        return ackermann(m - 1, 1)
    else:
        return ackermann(m - 1, ackermann(m, n - 1))

```


### 測試案例
| 測試輸入 S              | 預期 power set 大小 | 預期部分輸出                        |
| --------------------- | --------------- | ----------------------------------- |
| []                   | 1               | [[]]                                |
| ['a']                | 2               | [[],['a']]                          |
| ['a', 'b']           | 4               | [[], ['b'], ['a'], ['a', 'b']]   |
| ['a', 'b', 'c']      | 8               | 包含所有 3 元子集合                    |
| ['x', 'y', 'z', 'w'] | 16              | 測試遞迴深度與完整性                    |


## 測試與驗證


## 效能分析
1.Time Complexity: 超指數級別，無法以多項式描述。
2.Space Complexity: 遞迴深度可能會很深，stack 的空間成長快。

## 心得討論
Ackermann 函數是一個經典的超遞迴範例，初看之下結構簡單，但因為遞迴參數本身還依賴另一層遞迴的結果，導致展開速度極快、計算深度極深，我觀察到：遞迴版本實作簡單直觀，但在 Python 中容易遇到 stack overflow。
非遞迴版本需要小心模擬 call stack，對堆疊操作要非常謹慎，尤其是在處理 A(m-1, A(m, n-1)) 時必須等待前者計算完才能進行，這題也提醒我，並不是所有函數都適合遞迴實作，尤其在實務應用中要考量資源限制。
